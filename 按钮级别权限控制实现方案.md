# 按钮级别权限控制实现方案

## 1. 现状分析

### 1.1 数据模型层面（✅ 已支持）

系统数据模型**已经完全支持**按钮级别权限：

```java
// SysPermission实体
public enum Type {
    MENU,    // 菜单权限
    BUTTON   // 按钮权限
}
```

数据库中已定义按钮权限：
```sql
-- 用户管理按钮权限
('perm003', '用户查询', 'USER_SEARCH', 'BUTTON', 'perm002', 'user:search', 1, ...),
('perm004', '用户新增', 'USER_ADD', 'BUTTON', 'perm002', 'user:add', 2, ...),
('perm005', '用户编辑', 'USER_EDIT', 'BUTTON', 'perm002', 'user:edit', 3, ...),
('perm006', '用户删除', 'USER_DELETE', 'BUTTON', 'perm002', 'user:delete', 4, ...),
```

### 1.2 后端层面（⚠️ 部分实现）

**已实现：**
- CustomUserDetailsService已加载用户权限到SecurityContext
- 权限数据已正确关联（用户→角色→权限）

**未实现：**
- 登录接口未返回权限列表
- Controller接口未添加权限注解
- 缺少获取当前用户权限的接口

### 1.3 前端层面（❌ 完全未实现）

**存在问题：**
- 登录时未获取用户权限信息
- 没有权限状态管理（Pinia store）
- 按钮直接渲染，无权限控制
- 缺少权限指令（v-permission）

## 2. 完整实现方案

### 2.1 架构设计

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   前端界面   │────▶│  权限指令    │────▶│ 权限Store  │
│   按钮组件   │     │ v-permission │     │   Pinia    │
└─────────────┘     └─────────────┘     └─────────────┘
                            │                    │
                            ▼                    ▼
                    ┌─────────────┐     ┌─────────────┐
                    │  后端接口    │────▶│ Spring     │
                    │  @PreAuth    │     │ Security   │
                    └─────────────┘     └─────────────┘
```

### 2.2 后端实现方案

#### 2.2.1 修改登录响应，返回权限列表

```java
// 1. 修改LoginResponse
@Data
public class LoginResponse {
    private String token;
    private String tokenType = "Bearer";
    private String userId;
    private String username;
    private String realName;
    private String customerId;
    private List<String> permissions;  // 新增：权限编码列表
    private List<PermissionDTO> permissionDetails;  // 新增：权限详情（可选）
}

// 2. 创建PermissionDTO
@Data
public class PermissionDTO {
    private String code;    // 权限编码：USER_ADD
    private String name;    // 权限名称：用户新增
    private String type;    // 权限类型：BUTTON/MENU
}

// 3. 修改AuthenticationServiceImpl
@Override
public LoginResponse login(LoginRequest loginRequest) {
    // ... 原有认证逻辑
    
    // 获取用户权限
    List<SysPermission> permissions = permissionRepository.findByUserId(user.getId());
    List<String> permissionCodes = permissions.stream()
        .map(SysPermission::getCode)
        .collect(Collectors.toList());
    
    // 构建响应
    LoginResponse response = new LoginResponse();
    response.setToken(token);
    response.setUserId(user.getId());
    response.setUsername(user.getUsername());
    response.setRealName(user.getRealName());
    response.setCustomerId(user.getCustomerId());
    response.setPermissions(permissionCodes);  // 设置权限列表
    
    return response;
}
```

#### 2.2.2 添加获取当前用户权限的接口

```java
@RestController
@RequestMapping("/api/user")
public class UserController {
    
    @GetMapping("/current/permissions")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<PermissionDTO>> getCurrentUserPermissions() {
        String userId = SecurityUtil.getCurrentUserId();
        List<SysPermission> permissions = permissionRepository.findByUserId(userId);
        
        List<PermissionDTO> permissionDTOs = permissions.stream()
            .map(p -> {
                PermissionDTO dto = new PermissionDTO();
                dto.setCode(p.getCode());
                dto.setName(p.getName());
                dto.setType(p.getType().name());
                return dto;
            })
            .collect(Collectors.toList());
            
        return ResponseEntity.success(permissionDTOs);
    }
}
```

#### 2.2.3 为所有接口添加权限注解

```java
@RestController
@RequestMapping("/system/user")
public class SysUserController {
    
    @PostMapping("/search")
    @PreAuthorize("hasAuthority('USER_SEARCH')")
    public ResponseEntity<ResponsePageDataEntity<UserVo>> searchUsers(@RequestBody SearchUserCondition condition) {
        // 实现逻辑
    }
    
    @PostMapping("/save")
    @PreAuthorize("hasAuthority('USER_ADD')")
    public ResponseEntity<Void> save(@RequestBody SysUser user) {
        // 实现逻辑
    }
    
    @PutMapping("/update/{id}")
    @PreAuthorize("hasAuthority('USER_EDIT')")
    public ResponseEntity<Void> update(@PathVariable String id, @RequestBody SysUser user) {
        // 实现逻辑
    }
    
    @DeleteMapping("/delete/{id}")
    @PreAuthorize("hasAuthority('USER_DELETE')")
    public ResponseEntity<Void> delete(@PathVariable String id) {
        // 实现逻辑
    }
}
```

### 2.3 前端实现方案

#### 2.3.1 创建权限Store（Pinia）

```javascript
// stores/permission.js
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const usePermissionStore = defineStore('permission', () => {
  // 状态
  const permissions = ref([])  // 权限编码列表
  const permissionDetails = ref([])  // 权限详情列表
  
  // 计算属性
  const buttonPermissions = computed(() => 
    permissionDetails.value.filter(p => p.type === 'BUTTON')
  )
  
  const menuPermissions = computed(() => 
    permissionDetails.value.filter(p => p.type === 'MENU')
  )
  
  // 方法
  function setPermissions(permissionList) {
    permissions.value = permissionList
  }
  
  function setPermissionDetails(details) {
    permissionDetails.value = details
  }
  
  function hasPermission(code) {
    return permissions.value.includes(code)
  }
  
  function hasAnyPermission(codes) {
    return codes.some(code => permissions.value.includes(code))
  }
  
  function hasAllPermissions(codes) {
    return codes.every(code => permissions.value.includes(code))
  }
  
  function clear() {
    permissions.value = []
    permissionDetails.value = []
  }
  
  return {
    permissions,
    permissionDetails,
    buttonPermissions,
    menuPermissions,
    setPermissions,
    setPermissionDetails,
    hasPermission,
    hasAnyPermission,
    hasAllPermissions,
    clear
  }
})
```

#### 2.3.2 修改登录逻辑，保存权限信息

```javascript
// views/Login.vue 或 api/auth.js
import { usePermissionStore } from '@/stores/permission'

async function handleLogin() {
  try {
    const response = await authApi.login(loginForm)
    
    // 保存token和用户信息
    localStorage.setItem('userToken', response.data.token)
    localStorage.setItem('userInfo', JSON.stringify({
      userId: response.data.userId,
      username: response.data.username,
      realName: response.data.realName
    }))
    
    // 保存权限信息到store
    const permissionStore = usePermissionStore()
    permissionStore.setPermissions(response.data.permissions || [])
    
    // 如果登录响应包含权限详情
    if (response.data.permissionDetails) {
      permissionStore.setPermissionDetails(response.data.permissionDetails)
    }
    
    // 跳转到首页
    router.push('/dashboard')
  } catch (error) {
    console.error('登录失败:', error)
  }
}
```

#### 2.3.3 创建权限指令

```javascript
// directives/permission.js
import { usePermissionStore } from '@/stores/permission'

export const permission = {
  mounted(el, binding) {
    const { value } = binding
    const permissionStore = usePermissionStore()
    
    if (value && value instanceof Array && value.length > 0) {
      // 数组形式：['USER_ADD', 'USER_EDIT']
      const hasPermission = permissionStore.hasAnyPermission(value)
      if (!hasPermission) {
        el.style.display = 'none'
        // 或者直接移除元素
        // el.parentNode && el.parentNode.removeChild(el)
      }
    } else if (typeof value === 'string') {
      // 字符串形式：'USER_ADD'
      const hasPermission = permissionStore.hasPermission(value)
      if (!hasPermission) {
        el.style.display = 'none'
      }
    } else {
      throw new Error('v-permission指令需要权限值')
    }
  },
  updated(el, binding) {
    // 权限可能动态变化，更新时重新检查
    const { value } = binding
    const permissionStore = usePermissionStore()
    
    let hasPermission = false
    if (value && value instanceof Array && value.length > 0) {
      hasPermission = permissionStore.hasAnyPermission(value)
    } else if (typeof value === 'string') {
      hasPermission = permissionStore.hasPermission(value)
    }
    
    el.style.display = hasPermission ? '' : 'none'
  }
}

// main.js 中注册全局指令
import { permission } from '@/directives/permission'
app.directive('permission', permission)
```

#### 2.3.4 在组件中使用权限控制

```vue
<template>
  <div class="table-header">
    <div class="header-left">
      <!-- 使用v-permission指令控制按钮显示 -->
      <el-button 
        v-permission="'USER_ADD'"
        type="primary" 
        @click="handleAdd"
      >
        <el-icon><plus /></el-icon>
        新增用户
      </el-button>
      
      <!-- 支持多个权限（满足其一即可） -->
      <el-button 
        v-permission="['USER_ADD', 'USER_IMPORT']"
        type="warning" 
        @click="handleImport"
      >
        <el-icon><upload /></el-icon>
        导入
      </el-button>
    </div>
  </div>

  <el-table :data="tableData">
    <!-- ... 其他列 ... -->
    <el-table-column label="操作" width="200">
      <template #default="{ row }">
        <el-button 
          v-permission="'USER_VIEW'"
          type="text" 
          size="small" 
          @click="handleView(row)"
        >
          查看
        </el-button>
        
        <el-button 
          v-permission="'USER_EDIT'"
          type="text" 
          size="small" 
          @click="handleEdit(row)"
        >
          编辑
        </el-button>
        
        <el-button
          v-permission="'USER_DELETE'"
          type="text"
          size="small"
          @click="handleDelete(row)"
          style="color: #f56c6c;"
        >
          删除
        </el-button>
      </template>
    </el-table-column>
  </el-table>
</template>

<script setup>
import { usePermissionStore } from '@/stores/permission'

const permissionStore = usePermissionStore()

// 也可以在逻辑中判断权限
function handleOperation() {
  if (!permissionStore.hasPermission('USER_EDIT')) {
    ElMessage.error('您没有编辑权限')
    return
  }
  // 执行操作
}
</script>
```

#### 2.3.5 创建权限组件（可选）

```vue
<!-- components/PermissionButton.vue -->
<template>
  <el-button
    v-if="hasPermission"
    v-bind="$attrs"
    @click="$emit('click')"
  >
    <slot></slot>
  </el-button>
</template>

<script setup>
import { computed } from 'vue'
import { usePermissionStore } from '@/stores/permission'

const props = defineProps({
  permission: {
    type: [String, Array],
    required: true
  }
})

const permissionStore = usePermissionStore()

const hasPermission = computed(() => {
  if (Array.isArray(props.permission)) {
    return permissionStore.hasAnyPermission(props.permission)
  }
  return permissionStore.hasPermission(props.permission)
})
</script>

<!-- 使用方式 -->
<permission-button 
  permission="USER_ADD" 
  type="primary"
  @click="handleAdd"
>
  新增用户
</permission-button>
```

### 2.4 菜单权限控制

```javascript
// router/index.js
import { usePermissionStore } from '@/stores/permission'

// 路由守卫
router.beforeEach((to, from, next) => {
  const permissionStore = usePermissionStore()
  
  // 检查路由是否需要权限
  if (to.meta.permission) {
    if (!permissionStore.hasPermission(to.meta.permission)) {
      next({ path: '/403' })  // 无权限页面
      return
    }
  }
  
  next()
})

// 路由配置
const routes = [
  {
    path: '/user',
    component: UserManagement,
    meta: { 
      title: '用户管理',
      permission: 'USER_MANAGE'  // 菜单权限
    }
  }
]

// 动态生成菜单
function generateMenus() {
  const permissionStore = usePermissionStore()
  const allMenus = [
    {
      title: '用户管理',
      path: '/user',
      permission: 'USER_MANAGE',
      icon: 'User'
    },
    {
      title: '角色管理',
      path: '/role',
      permission: 'ROLE_MANAGE',
      icon: 'UserFilled'
    }
  ]
  
  // 过滤有权限的菜单
  return allMenus.filter(menu => 
    permissionStore.hasPermission(menu.permission)
  )
}
```

## 3. 实施步骤

### 3.1 第一阶段：后端改造（1-2天）

1. **修改登录接口**
   - 修改LoginResponse，添加permissions字段
   - 修改AuthenticationServiceImpl，返回用户权限列表

2. **添加权限查询接口**
   - 创建获取当前用户权限的接口
   - 支持刷新权限（权限变更后）

3. **添加接口权限注解**
   - 为所有需要权限控制的接口添加@PreAuthorize注解
   - 统一权限编码规范

### 3.2 第二阶段：前端基础设施（1-2天）

1. **创建权限Store**
   - 使用Pinia管理权限状态
   - 实现权限判断方法

2. **创建权限指令**
   - 实现v-permission指令
   - 支持字符串和数组形式

3. **修改登录流程**
   - 保存权限信息到Store
   - 持久化权限数据（可选）

### 3.3 第三阶段：界面改造（2-3天）

1. **改造所有按钮**
   - 添加v-permission指令
   - 统一权限编码

2. **改造菜单**
   - 根据权限动态生成菜单
   - 添加路由权限守卫

3. **测试验证**
   - 不同角色权限测试
   - 权限变更测试

## 4. 权限编码规范

### 4.1 命名规范

```
模块_操作

示例：
USER_ADD      - 用户新增
USER_EDIT     - 用户编辑
USER_DELETE   - 用户删除
USER_VIEW     - 用户查看
USER_EXPORT   - 用户导出
ROLE_ASSIGN   - 角色分配
```

### 4.2 权限层级

```
一级菜单权限：MODULE_MANAGE
二级菜单权限：MODULE_SUB_MANAGE
按钮权限：MODULE_ACTION
```

## 5. 注意事项

### 5.1 安全考虑

1. **前端权限仅用于UI控制**
   - 隐藏按钮不等于禁用功能
   - 后端必须进行权限验证

2. **权限信息加密传输**
   - 使用HTTPS
   - Token定期刷新

3. **权限缓存策略**
   - 登录时获取
   - 权限变更后需重新登录或刷新

### 5.2 性能优化

1. **权限数据缓存**
   ```javascript
   // 权限数据持久化
   const PERMISSION_CACHE_KEY = 'user_permissions'
   
   // 保存到localStorage
   localStorage.setItem(PERMISSION_CACHE_KEY, JSON.stringify(permissions))
   
   // 初始化时从缓存加载
   const cached = localStorage.getItem(PERMISSION_CACHE_KEY)
   if (cached) {
     permissionStore.setPermissions(JSON.parse(cached))
   }
   ```

2. **指令性能优化**
   - 避免在大量元素上使用
   - 使用v-if替代复杂场景

### 5.3 降级方案

```javascript
// 权限系统故障时的降级处理
const usePermission = () => {
  const permissionStore = usePermissionStore()
  
  const hasPermission = (code) => {
    try {
      return permissionStore.hasPermission(code)
    } catch (error) {
      console.error('权限检查失败:', error)
      // 降级策略：显示所有按钮，由后端控制
      return true
    }
  }
  
  return { hasPermission }
}
```

## 6. 测试用例

### 6.1 单元测试

```javascript
// 权限Store测试
describe('Permission Store', () => {
  it('should check single permission', () => {
    const store = usePermissionStore()
    store.setPermissions(['USER_ADD', 'USER_EDIT'])
    
    expect(store.hasPermission('USER_ADD')).toBe(true)
    expect(store.hasPermission('USER_DELETE')).toBe(false)
  })
  
  it('should check multiple permissions', () => {
    const store = usePermissionStore()
    store.setPermissions(['USER_ADD', 'USER_EDIT'])
    
    expect(store.hasAnyPermission(['USER_ADD', 'USER_DELETE'])).toBe(true)
    expect(store.hasAllPermissions(['USER_ADD', 'USER_EDIT'])).toBe(true)
  })
})
```

### 6.2 集成测试

1. **不同角色测试**
   - 管理员：所有按钮可见
   - 普通用户：仅查看按钮可见
   - 访客：无操作按钮

2. **权限变更测试**
   - 角色权限修改后重新登录
   - 验证按钮显示变化

## 7. 总结

本方案实现了完整的按钮级别权限控制：

1. **后端**：基于Spring Security的方法级权限控制
2. **前端**：基于Vue3的指令级权限控制
3. **数据**：RBAC模型的按钮权限定义

通过前后端配合，实现了：
- ✅ 按钮的显示/隐藏控制
- ✅ 接口的访问权限控制
- ✅ 菜单的动态生成
- ✅ 权限的统一管理

该方案具有良好的扩展性和维护性，可以满足企业级应用的权限管理需求。