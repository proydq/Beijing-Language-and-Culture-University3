# 前端权限数据库存储设计方案

## 当前问题分析

### 现状
1. **前端权限定义**：目前前端权限（按钮、菜单、路由）都硬编码在前端代码中
   - 权限常量定义在 `src/utils/permission.js`
   - 菜单权限配置在 `src/config/menu.js`
   - 路由权限配置在 `src/router/index.js`

2. **后端权限定义**：后端权限存储在数据库 `sys_permission` 表中
   - 只包含了API接口权限
   - 没有前端元素的权限配置

3. **存在的问题**：
   - 前端权限无法动态配置，需要修改代码重新部署
   - 前后端权限定义分离，维护困难
   - 无法实现细粒度的前端元素权限控制
   - 新增功能时需要同时修改前后端代码

## 解决方案设计

### 1. 扩展权限数据模型

#### 方案一：扩展现有 sys_permission 表
```sql
ALTER TABLE sys_permission ADD COLUMN permission_type VARCHAR(20) DEFAULT 'API' COMMENT '权限类型：API|MENU|BUTTON|ROUTE';
ALTER TABLE sys_permission ADD COLUMN frontend_code VARCHAR(100) COMMENT '前端权限标识';
ALTER TABLE sys_permission ADD COLUMN parent_id BIGINT COMMENT '父权限ID';
ALTER TABLE sys_permission ADD COLUMN component_path VARCHAR(200) COMMENT '前端组件路径';
ALTER TABLE sys_permission ADD COLUMN icon VARCHAR(50) COMMENT '图标';
ALTER TABLE sys_permission ADD COLUMN visible TINYINT DEFAULT 1 COMMENT '是否可见';
ALTER TABLE sys_permission ADD COLUMN order_num INT DEFAULT 0 COMMENT '排序';
ALTER TABLE sys_permission ADD COLUMN meta_data JSON COMMENT '扩展元数据';
```

#### 方案二：创建独立的前端权限表（推荐）
```sql
-- 前端权限表
CREATE TABLE sys_frontend_permission (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    permission_code VARCHAR(100) NOT NULL COMMENT '权限标识',
    permission_name VARCHAR(100) NOT NULL COMMENT '权限名称',
    permission_type VARCHAR(20) NOT NULL COMMENT '权限类型：MENU|BUTTON|ROUTE|ELEMENT',
    parent_id BIGINT COMMENT '父权限ID',
    path VARCHAR(200) COMMENT '路由路径',
    component VARCHAR(200) COMMENT '组件路径',
    icon VARCHAR(50) COMMENT '图标',
    order_num INT DEFAULT 0 COMMENT '排序',
    visible TINYINT DEFAULT 1 COMMENT '是否可见',
    meta_data JSON COMMENT '元数据（包含按钮位置、样式等）',
    api_permissions VARCHAR(500) COMMENT '关联的API权限codes，逗号分隔',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    KEY idx_permission_code (permission_code),
    KEY idx_parent_id (parent_id),
    KEY idx_type (permission_type)
) COMMENT '前端权限表';

-- 角色-前端权限关联表
CREATE TABLE sys_role_frontend_permission (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    role_id VARCHAR(50) NOT NULL COMMENT '角色ID',
    frontend_permission_id BIGINT NOT NULL COMMENT '前端权限ID',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_role_permission (role_id, frontend_permission_id),
    KEY idx_role_id (role_id)
) COMMENT '角色前端权限关联表';
```

### 2. 权限数据结构设计

```javascript
// 前端权限数据结构
{
  "menus": [
    {
      "id": 1,
      "code": "USER_MANAGEMENT",
      "name": "用户管理",
      "type": "MENU",
      "path": null,
      "icon": "user",
      "children": [
        {
          "id": 11,
          "code": "USER_LIST",
          "name": "用户列表",
          "type": "ROUTE",
          "path": "/user-management",
          "component": "UserManagement",
          "buttons": [
            {
              "id": 111,
              "code": "USER_ADD_BTN",
              "name": "新增用户",
              "type": "BUTTON",
              "apiPermissions": ["USER_ADD"]
            },
            {
              "id": 112,
              "code": "USER_EDIT_BTN",
              "name": "编辑用户",
              "type": "BUTTON",
              "apiPermissions": ["USER_EDIT"]
            }
          ]
        }
      ]
    }
  ],
  "elements": {
    "USER_ADD_BTN": {
      "visible": true,
      "disabled": false
    },
    "USER_EDIT_BTN": {
      "visible": true,
      "disabled": false
    }
  }
}
```

### 3. 实现步骤

#### 第一步：创建数据库表和初始数据
1. 创建 `sys_frontend_permission` 表
2. 创建 `sys_role_frontend_permission` 表
3. 将现有的前端权限配置导入数据库

#### 第二步：后端接口改造
1. 创建前端权限管理相关实体类
2. 修改登录接口，返回用户的前端权限配置
3. 创建前端权限管理接口（增删改查）

#### 第三步：前端改造
1. 修改登录逻辑，从后端获取权限配置
2. 动态生成路由
3. 动态生成菜单
4. 动态控制按钮显示

### 4. 示例数据

```sql
-- 菜单权限
INSERT INTO sys_frontend_permission (permission_code, permission_name, permission_type, parent_id, icon, order_num) VALUES
('SYSTEM_MENU', '系统管理', 'MENU', NULL, 'setting', 1),
('USER_MENU', '用户管理', 'MENU', 1, 'user', 1);

-- 路由权限
INSERT INTO sys_frontend_permission (permission_code, permission_name, permission_type, parent_id, path, component, api_permissions) VALUES
('USER_LIST_ROUTE', '用户列表', 'ROUTE', 2, '/user-management', 'UserManagement', 'USER_VIEW,USER_SEARCH');

-- 按钮权限
INSERT INTO sys_frontend_permission (permission_code, permission_name, permission_type, parent_id, api_permissions, meta_data) VALUES
('USER_ADD_BTN', '新增用户按钮', 'BUTTON', 3, 'USER_ADD', '{"position": "toolbar", "type": "primary"}'),
('USER_EDIT_BTN', '编辑用户按钮', 'BUTTON', 3, 'USER_EDIT', '{"position": "table", "type": "link"}'),
('USER_DELETE_BTN', '删除用户按钮', 'BUTTON', 3, 'USER_DELETE', '{"position": "table", "type": "danger"}');

-- 分配权限给角色
INSERT INTO sys_role_frontend_permission (role_id, frontend_permission_id) 
SELECT 'role001', id FROM sys_frontend_permission; -- 管理员拥有所有权限
```

### 5. 优势

1. **统一管理**：前后端权限统一在数据库管理
2. **动态配置**：无需修改代码即可调整权限
3. **细粒度控制**：可以控制到每个按钮、每个页面元素
4. **版本控制**：权限变更有记录可查
5. **降低耦合**：前端不再硬编码权限逻辑

### 6. 实施建议

1. **分阶段实施**：
   - Phase 1: 创建数据结构，保持现有硬编码兼容
   - Phase 2: 逐步迁移权限配置到数据库
   - Phase 3: 完全动态化，移除硬编码

2. **向后兼容**：
   - 保留现有权限常量作为备份
   - 提供配置开关，可以切换使用数据库或硬编码

3. **性能优化**：
   - 登录时一次性加载所有权限配置
   - 使用Redis缓存权限数据
   - 前端使用Pinia持久化存储

### 7. API设计

```java
// 登录返回数据结构
{
  "token": "xxx",
  "userInfo": {...},
  "permissions": {
    "apis": ["USER_ADD", "USER_EDIT"], // API权限
    "frontend": {
      "menus": [...],      // 菜单树
      "routes": [...],     // 路由配置
      "elements": {...}    // 元素权限
    }
  }
}
```